# 数据结构与算法

## 含义

### 数据结构

#### 一组数据的存储结构

#### 数据结构为算法服务

### 算法

#### 操作数据的一组方法

#### 算法要作用在特定的数据结构之上

## 复杂度分析

### 时间复杂度

#### 渐进时间复杂度，表示代码执行时间随数据规模增长的变化趋势

#### 分析

##### 只关注循环执行次数最多的一段代码

##### 加法法则：总复杂度 = 量级最大的那段代码的复杂度

##### 乘法法则：嵌套代码的复杂度 = 嵌套内外代码复杂度的乘积

#### 常见复杂度量级

##### 常量阶 O(1)

###### 当不存在递归、循环

##### 对数阶 O(logn)

###### 循环变量按倍数增长

##### 线性阶 O(n)

##### 线性对数阶 O(nlogn)

##### 平方阶 O(n^2)

##### 指数阶 O(2^n)

##### 阶乘阶 O(n!)

#### 场景

##### 最好

##### 最坏

##### 平均

###### 加权平均时间复杂度、期望时间复杂度

##### 均摊

###### 摊还分析法

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度

### 空间复杂度

#### 渐进空间复杂度，表示存储空间与数据规模之间的增长关系

## 数据结构

### 线性表

#### 数组

##### 插入低效

###### 优化：插入索引K, 则只将原K元素移到数组尾部

##### 删除低效

###### 优化：标记清除

##### vs. ArrayList

###### 封装细节

###### 动态扩容

##### 内存空间连续

###### 所以申请时如果连续空间不足，会OOM

#### 链表

##### 种类

###### 单链表

###### 双向链表

####### LinkedHashMap

####### 用空间换时间

###### 循环链表

###### 双向循环链表

###### 静态链表

##### 技巧

###### 理解指针或引用的含义

###### 警惕指针丢失

###### 利用哨兵简化实现难度

####### 虚拟空头

###### 留意边界条件处理

####### 空、1节点、2节点

###### 举例、画图

##### 例题

###### LRU 缓存

使用有序单链表，尾部表示最早使用的节点。插入节点时，
- 遍历链表，查询是否已存在；
- 若存在，则从原位置删除、插入到头；
- 若不存在，且缓存未满，则插入到头；
- 若不存在，且缓存已满，则删除尾部节点，插入到头。


###### 判断字符串回文

###### 206. 单链表反转

No. 206 https://leetcode.com/problems/reverse-linked-list/ 

###### 141. 链表中环的检测

No. 141 https://leetcode.com/problems/linked-list-cycle/
No. 142 https://leetcode.com/problems/linked-list-cycle-ii/

###### 21. 有序链表合并

No. 21 https://leetcode.com/problems/merge-two-sorted-lists/


###### 19. 删除链表倒数第n个节点

No. 19 https://leetcode.com/problems/remove-nth-node-from-end-of-list/


###### 876. 求链表中间节点

No. 876 https://leetcode.com/problems/middle-of-the-linked-list/

#### 栈

##### 定义

###### 受限的线性表

####### 入栈 push()

####### 出站pop()

##### 实现

###### 顺序栈

####### 用数组实现

###### 链式栈

####### 用链表实现

##### 应用

###### 函数调用栈

###### 表达式求值

####### 操作数栈

####### 运算符栈

###### 括号匹配

###### 浏览器前进后退

####### 两个栈

##### 例题

###### 20. Valid Parentheses

No. 20 https://leetcode.com/problems/valid-parentheses/


###### 155. Min Stack

https://leetcode.com/problems/min-stack/

###### 232. Implement Queue using Stacks

https://leetcode.com/problems/implement-queue-using-stacks/

###### 844. Backspace String Compare

https://leetcode.com/problems/backspace-string-compare/

###### 224. Basic Calculator

https://leetcode.com/problems/basic-calculator/

###### 682. Baseball Game

https://leetcode.com/problems/baseball-game/

###### 496. Next Greater Element I

https://leetcode.com/problems/next-greater-element-i/

#### 队列

##### 定义

###### 受限的线性表

####### 入队 enqueue()

####### 出队 dequeue()

##### 实现

###### 顺序队列

####### 用数组实现

```java
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  
  private int head = 0;
  private int tail = 0;
  
  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    ++head;
    return ret;
  }
  
  // 入队
  public boolean enqueue(String item) {
    // 如果 tail == n 表示队列已经满了
    if (tail == n) return false;
    items[tail] = item;
    ++tail;
    return true;
  }
  
  
     // 入队 + 数据搬移
  public boolean enqueue(String item) {
    if (tail == n) {
      // tail ==n && head==0，表示整个队列都占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; ++i) {
        items[i-head] = items[i];
      }
      // 搬移完之后重新更新 head 和 tail
      tail -= head;
      head = 0;
    }
    
    items[tail] = item;
    ++tail;
    return true;
  }

}

```

######## 队空：head == tail

######## 队满：tail == n

###### 链式队列

####### 用链表实现

##### 种类

###### 普通队列

###### 循环队列

```java
public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  
  private int head = 0;
  private int tail = 0;

  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}

```

####### 队空：head == tail

####### 队满：(tail + 1) % n == head

###### 双端队列

###### 阻塞队列

####### 生产者消费者模型

###### 并发队列

###### 阻塞并发队列

### 散列表

#### 散列函数

#### 冲突解决

##### 链表法

##### 开放寻址

##### 其他

#### 动态扩容

#### 位图

### 树

#### 二叉树

##### 平衡二叉树

##### 二叉查找树

##### 平衡二叉查找树

###### AVL 树

###### 红黑树

##### 完全二叉树

##### 满二叉树

#### 多路查找树

##### B 树

##### B+ 树

##### 2-3 树

##### 2-3-4 树

#### 堆

##### 小顶堆

##### 大顶堆

##### 优先级队列

##### 斐波那契堆

##### 二项堆

#### 其他

##### 树状数组

##### 线段树

### 图

#### 图的存储

##### 邻接矩阵

##### 邻接表

#### 拓扑排序

#### 最短路径

#### 关键路径

#### 最小生成树

#### 二分图

#### 最大流

## 常见思路

### 递归

#### 三个条件

##### 一个问题的解可以分解为几个子问题的解

##### 该问题与子问题求解思路完全一样

##### 存在递归终止条件

#### 思路

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码

##### 写出递推公式

##### 找到终止条件

#### 如何写

##### 严格定义递归函数作用：参数、返回值、side-effect

##### 先一般，后特殊

##### 每次调用必须缩小问题规模

##### 每次问题规模缩小程度必须为1

### 循环

#### 定义循环不变式，循环体每次结束后保持循环不变式

#### 先一般，后特殊

#### 每次必须向前推进循环不变式中涉及的变量值

#### 每次推进的规模必须为1

### 二分

#### [a, b) 前闭后开

##### [a, b) + [b, c) = [a, c)

##### b - a = len([a, b))

##### [a, a) ==> empty range

## 基本算法思想

### 贪心算法

### 分治算法

### 动态规划

### 回溯算法

### 枚举算法

## 常见算法场景

### 排序

#### 二分查找

##### O(logN)

#### 排序算法

##### O(n^2)

###### 冒泡排序

自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。

即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

```java
for (int i=0; i<data.length; i++) {
  for (int j=i+1; j<data.length; j++) {
    if (data[i] > data[j]) {
       int tmp = data[j];
       data[j] = data[i];
       data[i] = tmp;
    }
  }
}
```

####### 三次赋值

###### 插入排序

假设前面(n-1) [n>=2] 个数已经是排好顺序的。
把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。
- 找到待插入位置，查找过程中移动数据
- 把n插入找到的位置。

```java
for (int i = 1; i < data.length; i++) {
  int value = data[i];
  int targetIndex = -1;
            
  // 找到待插入位置
  for (int j = i - 1; j >= 0; j--) {
    if (data[j] > value) {
      data[j+1] = data[j]; // 数据移动
      targetIndex = j;
    } else {
      break;
    }
  }
  if (targetIndex >= 0) {
     data[targetIndex] = value;
  }
}
```

####### 一次赋值

###### 选择排序

思路类似插入排序，分为已排序区、未排序区；
每次从未排序区找到最小元素，放到已排序区末尾。

```java
// 重复（元素个数-1）次
for (int i = 0; i < n; i++) {
  // 把第一个没有排序过的元素设置为最小值
  int min = i;
  // 遍历每个没有排序过的元素
  for (int j = i+1; j < n; j++) { 
    // 如果元素 < 现在的最小值，将此元素设置成为新的最小值
    if (data[j] < data[min]) {
        min = j;
    }
  }
            
  // 将最小值和第一个没有排序过的位置交换
  if (data[min] < data[i]) {
     int temp = data[min];
     data[min] = data[i];
     data[i] = temp;
  }
            
}
```

###### 希尔排序

算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行`直接插入排序`，
然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。
当增量减到1时，进行直接插入排序后，排序完成。

##### O(nlogn)

###### 归并排序

分治思想，将两个有序表合并成一个新的有序表。即：

- 把待排序序列分为若干个子序列，每个子序列是有序的。
- 然后再把有序子序列合并为整体有序序列。

###### 快速排序

- 选择一个基准元素，通常选择第一个元素或者最后一个元素。
- 通过一趟扫描，将待排序列分成两部分：一部分比基准元素小；一部分大于等于基准元素。
- 
此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。

###### 堆排序

堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。

所以堆排序有两个函数组成。
- 一是建堆的渗透函数，
- 二是反 复调用渗透函数实现排序的函数。

##### O(n)

###### 计数排序

###### 基数排序

- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
- 然后，从最低位开始，依次进行一次排序。
- 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。


###### 桶排序

#### JDK排序算法

##### 原始数据类型

###### 快排

###### 双轴快排 Dual-Pivot QuickSort 

http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/DualPivotQuicksort.java

##### 对象类型

###### TimSort

####### 结合 归并 + 二分插入binarySort

##### 并行排序算法 parallelSort

#### 指标

##### 内存消耗

##### 稳定性

##### 时间复杂度

###### 逆序度

#### 参考

https://visualgo.net/zh/sorting

https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

### 搜索

#### 深度优先搜索

#### 广度优先搜索

#### A*启发式搜索

### 查找 

#### 线性表查找

#### 树结构查找

#### 散列表查找

### 字符串匹配

#### 朴素

#### KMP

#### Robin-Karp

#### Boyer-Moore

#### AC 自动机

#### Trie

#### 后缀数组

### 其他

#### 数论

#### 计算几何

#### 概率分析

#### 并查集

#### 拓扑网络

#### 矩阵运算

#### 线性规划
